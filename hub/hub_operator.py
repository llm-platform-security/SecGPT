# Library for spokes
from spoke.spoke import Spoke

# Library for vanilla spokes
from spoke.vanilla_spoke import VanillaSpoke

# Libraries for IPC
import socket
import multiprocessing
from helpers.isc.socket import Socket
from helpers.isc.message import Message
import uuid

# Library for permission helpers
from helpers.permission.permission import get_user_consent, request_replan

# Library for configuration settings
from helpers.configs.configuration import Configs

# Library for getting timeout setting
from helpers.sandbox.sandbox import TIMEOUT

# Library for parsing entities
import ast

# Set a start method for platforms other than Linux
import platform
if platform.system() != "Linux":
    from multiprocessing import set_start_method
    set_start_method("fork")


# HubOperator is used to route queries and manage the spokes
class HubOperator:
    # Initialize the hub manager
    def __init__(self, tool_importer, memory_obj):
        # Maintain a tool importer
        self.tool_importer = tool_importer

        # Maintain tool information
        self.tool_functions, self.functionality_list = self.tool_importer.get_tool_functions()  
        self.tools = self.tool_importer.get_all_tools()

        self.function_tools = {}
        for tool, functions in self.tool_functions.items():
            for function in functions:
                self.function_tools[function] = tool

        self.tool_names = list(self.tool_functions.keys())

        # Maintain a dictionary of Spoke and tool mapping
        self.spoke_tool = {}

        # Maintain a vanilla spoke (no app collaboration is needed)
        self.vanilla_spoke = None

        # Maintain a memory object
        self.memory_obj = memory_obj

        # Maintain a spoke counter
        self.spoke_counter = 0

        # Get user_id
        self.user_id = Configs.user_id

        # Maintain a plan and an app list generated by the planner
        self.plan = {}
        self.app_list = []
        
        self.query = ""

    # Run hub operator to route user queries
    def run(self, query, plan):
        self.query = query
        
        # Filter the plan
        self.filter_plan(plan)
        num_step_list = len(self.plan)

        consent = True
        replan_consent = False
        
        # No app is needed to address the user query
        if num_step_list == 0:
            if self.vanilla_spoke is None:
                self.vanilla_spoke = VanillaSpoke()
            results = self.vanilla_spoke.llm_execute(query)  
            
        # Apps are executed in a cascaded manner
        elif num_step_list == 1:
            startup_app = self.plan[0][0]['name']
            consent, results = self.run_initial_spoke(query, startup_app)
            
        # Apps can be executed concurrently, use a dedicated spoke for routing the query
        else:
            startup_app = ""
            consent, results = self.run_initial_spoke(query, startup_app)

        # Consider re-planing if the user does not consent
        if not consent:
            replan_consent = request_replan(results)
        
        return replan_consent, results
        

    # Filter the plan based on the available tools and group the steps
    def filter_plan(self, plan):
        filtered_steps = [step for step in plan['steps'] if step['name'] in self.tool_names]
        output_key_to_step = {}
        grouped_steps = []

        for step in filtered_steps:
            # Determine if the step is dependent on a previous step
            dependent = False
            for input_key, input_value in step['input'].items():
                if isinstance(input_value, str) and input_value.startswith('<') and input_value.endswith('>'):
                    dependent_key = input_value[1:-1] 
                    if dependent_key in output_key_to_step:
                        dependent = True
                        grouped_steps[output_key_to_step[dependent_key]].append(step)
                        break
            
            # If the step is not dependent on any previous step's output, start a new group
            if not dependent:
                grouped_steps.append([step])

            # Record the output key of this step
            if 'output' in step:
                output_key_to_step[step['output']] = len(grouped_steps) - 1
            
        self.plan = grouped_steps
        self.app_list = [[step['name'] for step in step_list] for step_list in self.plan]
        

    # Run initial spoke with user permissions
    def run_initial_spoke(self, query, startup_app):
        if startup_app:
            action_message = f'Your request "{query}" requires executing "{startup_app}"'
            consent = get_user_consent(self.user_id, startup_app, action_message, True, 'exec')
        else:
            consent = True
        
        if not consent:
            results = f'The user declined to use "{startup_app}" to resolve the request "{query}"'
        
        else:
            entities = self.memory_obj.retrieve_entities(query)
            entity_dict = ast.literal_eval(entities)
            all_empty = all(value == '' for value in entity_dict.values())
            if all_empty:
                entities = ""
            results = self.execute_app_spoke(query, entities, startup_app, True)

        return consent, results


    # Execute a Spoke to solve a step
    def execute_app_spoke(self, query, entities, requested_app, flag=False):    
        # Check whether the Spoke exists
        if requested_app in self.spoke_tool.keys():
            print("Using " + requested_app + " spoke ...\n")
            # Use the existing Spoke to solve this step
            session_id = uuid.uuid4()
            spoke_id = self.spoke_tool[requested_app]['id']
            spoke_session_id = self.user_id + ":" + str(spoke_id) + ":" + str(session_id)
            spoke = self.spoke_tool[requested_app]['spoke']
            
            if entities:
                spoke_entities = spoke.memory_obj.retrieve_entities(query)
                if entities == spoke_entities:
                    entities = ""
                else:
                    action_message = f'Your data "{entities}" is sharing with "{requested_app}"'
                    data_consent = get_user_consent(self.user_id, requested_app, action_message, False, 'data')   
                    if not data_consent:
                        entities = ""

            # Create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)

            p = multiprocessing.Process(target=spoke.run_process, args=(child_sock, query, spoke_session_id, entities))
            p.start()
            results = self.handle_request(parent_sock)
            p.join(timeout = TIMEOUT)
            child.close()
            return results

        elif requested_app == "":
            # Create a dedicated Spoke to route the query
            # Create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)

            session_id = uuid.uuid4()
            spoke_session_id = self.user_id + ":" + str(self.spoke_counter) + ":" + str(session_id)
            spoke = Spoke(tool=None, functionalities=[], flag=flag)
            self.spoke_counter += 1
            
            p = multiprocessing.Process(target=spoke.run_process, args=(child_sock, query, spoke_session_id, entities))
            p.start()
            results = self.handle_request(parent_sock)
            p.join(timeout = TIMEOUT)
            child.close()
            return results  

        else:
            # Create a new Spoke to solve this step
            # get the tool object based on the tool name
            print("Using " + requested_app + " spoke ...\n")
            tool = [t for t in self.tools if t.name == requested_app][0]

            tool_functionalities = self.tool_functions[tool.name]
            tool_spec = self.tool_importer.get_tool_function(requested_app)

            # Create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)

            session_id = uuid.uuid4()
            spoke_session_id = self.user_id + ":" + str(self.spoke_counter) + ":" + str(session_id)
            self.spoke_tool[requested_app] = {
                'id': self.spoke_counter,
                'spoke': Spoke(tool=tool, functionalities=tool_functionalities, spec=tool_spec, flag=flag),
                'tool': tool
            } 
            self.spoke_counter += 1

            spoke = self.spoke_tool[requested_app]['spoke']

            if entities:
                action_message = f'Your data "{entities}" is sharing with "{requested_app}"'
                data_consent = get_user_consent(self.user_id, requested_app, action_message, False, 'data')   
                if not data_consent:
                    entities = ""
            
            p = multiprocessing.Process(target=spoke.run_process, args=(child_sock, query, spoke_session_id, entities))
            p.start()
            results = self.handle_request(parent_sock)
            p.join(timeout = TIMEOUT)
            child.close()
            return results

    # It should handle different types of requests/responses from Spokes
    def handle_request(self, parent_sock):
        while True:
            data = parent_sock.recv()

            if data['message_type'] == 'final_response':
                return data['response']

            if data['message_type'] == 'function_probe_request':
                function = data['requested_functionality']
                spoke_session_id = data['spoke_id']

                if function not in self.function_tools.keys():
                    response = Message().no_functionality_response(spoke_session_id, function)
                    parent_sock.send(response)
                    continue

                request_app = ""
                spoke_id = spoke_session_id.split(":")[1]
                for app, spoke in self.spoke_tool.items():
                    if str(spoke['id']) == spoke_id:
                        request_app = app
                        break

                app = self.function_tools[function]
                
                flag = False
                if request_app:
                    action_message = f'"{request_app}" requests to execute "{app}"'
                    
                    for step_app_list in self.app_list:
                        if app in step_app_list and request_app in step_app_list:
                            flag = True
                            break
                    
                    consent = get_user_consent(self.user_id, request_app+"->"+app, action_message, flag, 'exec') 
                    
                else:
                    action_message = f'Your request "{self.query}" requires executing "{app}"'
                    
                    for step_app_list in self.app_list:
                        if app in step_app_list:
                            flag = True
                            break

                    consent = get_user_consent(self.user_id, app, action_message, flag, 'exec')

                if not consent:
                    response = Message().functionality_denial_response(spoke_session_id, function)            
                else:                    
                    functionality_spec = self.tool_importer.get_tool_function(app, function)
                    response = Message().function_probe_response(spoke_session_id, functionality_spec)

                parent_sock.send(response)

            if data['message_type'] == 'app_request':
                functionality_request = data['functionality_request']
                spoke_session_id = data['spoke_id']

                if functionality_request not in self.function_tools.keys():
                    response_message = functionality_request+" not found"
                    response = Message().no_functionality_response(functionality_request)
                else:
                    tool = self.function_tools[functionality_request]

                    entities = self.memory_obj.retrieve_entities(str(data))
                    entity_dict = ast.literal_eval(entities)
                    all_empty = all(value == '' for value in entity_dict.values())
                    if all_empty:
                        entities = ""

                    app_response = self.execute_app_spoke(str(data), entities, tool, False)
                    response_message = app_response
                    response = Message().app_response(spoke_session_id, app_response)

                if request_app:
                    action_message = f'"{app}" is returning the following response to "{request_app}":\n"{response_message}"'
                    consent = get_user_consent(self.user_id, app+"->"+request_app, action_message, True, 'collab') 
                else:
                    action_message = f'"{app}" is returning the following response:\n"{response_message}"'
                    consent = get_user_consent(self.user_id, app, action_message, True, 'collab') 
                    
                if consent:  
                    parent_sock.send(response)
                else:
                    parent_sock.send(Message().no_functionality_response(functionality_request))
