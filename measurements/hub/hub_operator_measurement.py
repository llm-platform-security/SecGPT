from spoke.spoke_measurement import Spoke

# Import libraries for IPC
import socket
import multiprocessing
from helpers.isc.socket import Socket


from helpers.isc.message import Message

import uuid

from helpers.permission.permission import get_user_consent

# Library for shell_spoke
from spoke.shell_spoke_measurement import ShellSpokeExtraction, ShellSpoke

from helpers.configs.configuration import Configs

import time

# for recording time
from helpers.utilities.time_recorder import secgpt_record

# HubOperator is used to manage the Spokes
class HubOperator:

    # Initialize the hub manager
    def __init__(self, tools, tool_functions, tool_importer, memory_obj, task):
        # Maintain tool information
        self.tool_functions = tool_functions
        self.task = task
        
        self.function_tools = {}
        for tool, functions in self.tool_functions.items():
            for function in functions:
                self.function_tools[function] = tool

        self.tool_names =  list(self.tool_functions.keys())
        # self.functionality_list = list(self.tool_functions.values())
        self.tools = tools

        # Maintain a dictionary of Spoke and tool mapping
        self.spoke_tool = {}

        
        # Maintain a shell spoke
        self.shell_spoke = None
        
        # Maintain a tool importer
        self.tool_importer = tool_importer
        
        # Maintain a memory object
        self.memory_obj = memory_obj
        
        # Maintain a spoke counter
        self.spoke_counter = 0
        
        # Get user_id
        self.user_id = Configs.user_id
        
        # Maintain an app list generated by the planner
        self.app_list = []
        
        

    def run(self, query, app_list):
        # Filter apps
        for app in app_list:
            if app not in self.tool_names:
                app_list.remove(app)
        self.app_list = app_list 
        if self.app_list == []:
            startup_app = ''
        else:
            startup_app = self.app_list[0]
        
        # check whether to use the startup_app to solve the query
        if startup_app in self.tool_names: 
            
            start_memory_extraction_time = time.time()
            entities = self.memory_obj.retrieve_entities(query)
            memory_extraction_time = time.time() - start_memory_extraction_time

            # Hub memory time - entity memory extraction from the hub memory
            secgpt_record(hub_memory_time = memory_extraction_time)
            
            # action_message = "app: "+ startup_app + "\n" + "request: " + query + "\n" + "shared data: "+str(entities)+"\n"
            consent = True #get_user_consent(self.user_id, startup_app, action_message, True)        
            if consent:
                start_spoke_time = time.time()
                results = self.execute_app_spoke(query, entities, startup_app, True)
                spoke_time = time.time() - start_spoke_time
                # Spoke plan and execution time
                secgpt_record(spoke_total_time = spoke_time)
            else:
                results = "User denied the request"
        else:
            if self.shell_spoke is None:
                if self.task.name == "Chat Extraction" or self.task.name == "Email Extraction":
                    self.shell_spoke = ShellSpokeExtraction(task=self.task)
                else:
                    self.shell_spoke = ShellSpoke()
            results = self.shell_spoke.llm_execute(query)
            
        return results
        
        
    def execute_app_spoke(self, query, entities, requested_app, flag=False):
        if requested_app in self.spoke_tool.keys():
            # Use the existing Spoke to solve this step
            
            start_spoke_init_time = time.time()
            
            session_id = uuid.uuid4()
            spoke_id = self.spoke_tool[requested_app]['id']
            spoke_session_id = self.user_id + ":" + str(spoke_id) + ":" + str(session_id)
            spoke = self.spoke_tool[requested_app]['spoke']
            
            # create a tool after create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)

            spoke_init_time = time.time() - start_spoke_init_time
            # Spoke initialization time
            secgpt_record(spoke_init_time = spoke_init_time)

            p = multiprocessing.Process(target=spoke.run_process, args=(child_sock, query, spoke_session_id, entities))

            p.start()
            results = self.handle_request(parent_sock)
            
            p.join()
            child.close()
            return results
            

        else:
            # Create a new Spoke to solve this step
            # get the tool object based on the tool name
            
            start_spoke_init_time = time.time()
            
            tool = [t for t in self.tools if t.name == requested_app][0]

            tool_functionalities = self.tool_functions[tool.name]

            # create a tool after create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)
        
            session_id = uuid.uuid4()
            spoke_session_id = self.user_id + ":" + str(self.spoke_counter) + ":" + str(session_id)
            self.spoke_tool[requested_app] = {
                'id': self.spoke_counter,
                'spoke': Spoke(tool=tool, functionalities=tool_functionalities, flag=flag), #, functionality_list = broadcast_functionality
                'tool': tool
            } #, id=spoke_session_id
            self.spoke_counter += 1

            spoke = self.spoke_tool[requested_app]['spoke']
            spoke_init_time = time.time() - start_spoke_init_time

            # Spoke initialization time
            secgpt_record(spoke_init_time = spoke_init_time)
 
            p = multiprocessing.Process(target=spoke.run_process, args=(child_sock, query, spoke_session_id, entities))
            p.start()
            results = self.handle_request(parent_sock)
            # self.memory_obj.record_history(query, str(results))
            p.join()
            child.close()
            return results
                


    # It should handle different types of requests/responses from Spokes
    def handle_request(self, parent_sock):
        while True:
            data = parent_sock.recv()
            
            if data['message_type'] == 'final_response':
                return data['response']
            
            if data['message_type'] == 'function_probe_request':
                function = data['requested_functionality']
                spoke_session_id = data['spoke_id']
                if function not in self.function_tools.keys():
                    parent_sock.send("Functionality not found")
                    
                    continue
                tool = self.function_tools[function]
                functionality_spec = self.tool_importer.get_tool_description_and_args(tool)
                response = Message().function_probe_response(spoke_session_id, functionality_spec)
                
                parent_sock.send(response)
            
            if data['message_type'] == 'app_request':

                functionality_request = data['functionality_request']
                spoke_session_id = data['spoke_id']

                if functionality_request not in self.function_tools.keys():
                    response = Message().no_functionality_response(functionality_request)
                else:
                    tool = self.function_tools[functionality_request]
                    
                    start_memory_extraction_time = time.time()
                    entities = self.memory_obj.retrieve_entities(str(data))
                    memory_extraction_time = time.time() - start_memory_extraction_time
                    secgpt_record(adt_hub_memory_time = memory_extraction_time)
                    
                    
                    # action_message = "app: "+ tool + "\n" + "request: " + str(data["request_body"]) + "\n" + "shared data: "+str(entities)+"\n"
                    #+ "functionality: " + str(functionality_request) + "\n"
                    if tool in self.app_list:
                        flag = True
                    else:
                        flag = False
                    consent = True #get_user_consent(self.user_id, tool, action_message, flag)
                    if consent:
                        app_response = self.execute_app_spoke(str(data), entities, tool, False)
                        response = Message().app_response(spoke_session_id, app_response)
                    else:
                        response = Message().functionality_denial_response(functionality_request)
                
                parent_sock.send(response)
                
